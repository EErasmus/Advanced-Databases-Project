Cardinality:
------------------------
address:           2452018 => collected from kaggle
person:            1000000 => generated from mockaroo
faculty:             12608 => hand generated
university:            788 => generated from mockaroo
course:                999 => hand generated
role:                  999 => hand generated
grades:                999 => hand generated
person_to_address: 2000000 => hand generated




==> 01_sql_for_loading_addresses.sql <==
--ALTER SESSION SET container = xepdb1;
--
--SELECT
--    COUNT(*)
--FROM
--    us_zipcodes;
--
--SELECT
--    *
--FROM
--    us_addresses_subset;
--
--SELECT
--    street_number,
--    street, 
--
--CREATE TABLE us_addresses_subset
--    AS
--        SELECT
--            *
--        FROM
--            (
--                SELECT
--                    street_number,
--                    street,
--                    postcode
--                FROM
--                    us_addresses
--                WHERE
--                    postcode IS NOT NULL
--                    AND length(TRIM(postcode)) > 0
--                ORDER BY
--                    dbms_random.random
--            )
--        WHERE
--            ROWNUM < 2540000;

--select state, count(*) from (
create view x_us_addresses_subset_final AS
SELECT
    upper(addr.street_number) street_number,
    upper(addr.street) street,
    zip.primary_city city,
    zip.state state,
    zip.country country,
    lpad(zip.zip, 5, '0') postal_code
FROM
         (
        SELECT
            *
        FROM
            us_addresses_subset
        WHERE
            street_number IS NOT NULL
            AND street IS NOT NULL
    ) addr
    JOIN us_zipcodes zip ON ( lpad(zip.zip,5,'0') = lpad( substr(addr.postcode, 0, 5),5,'0') )
--)
--group by state
--order by count(*)

-- CREATE THE ADDRESS TABLE --
DROP TABLE address;

CREATE TABLE address (
    address_id      INTEGER GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    name            VARCHAR2(70 CHAR),
    addr1           VARCHAR2(80 CHAR),
    addr2           VARCHAR2(80 CHAR),
    postal_code     VARCHAR2(15 CHAR),
    city            VARCHAR2(30 CHAR),
    state           VARCHAR2(2 CHAR),
    country         VARCHAR2(50),
    alternate_form  VARCHAR2(200 CHAR)
);

ALTER TABLE address ADD CONSTRAINT address_pk PRIMARY KEY ( address_id );

-- LOAD THE ADDRESS TABLE --
INSERT INTO address (
    addr1,
    postal_code,
    city,
    state,
    country,
    alternate_form
)
    SELECT
        usa.street_number
        || ' '
        || usa.street,
        usa.postal_code,
        upper(usa.city),
        usa.state,
        'USA',
        usa.street_number
        || ' '
        || usa.street
        || '\n'
        || usa.city
        || ', '
        || usa.state
        || ' '
        || usa.postal_code
    FROM
        us_addresses_subset_final usa;

-- remove ugly data    
DELETE
FROM
    address
WHERE
    addr1 LIKE '%0000%';
commit;


==> 02_person.sql <==
-- Code for creating person table --

-- get field sizes --
SELECT
    MAX(length(lastname))            lastname,
    MAX(length(firstname))           firstname,
    MAX(length(fullname) + 4)        fullname,
    MAX(length(gender))              gender
FROM
    x_person;
    
-- CREATE THE PERSON TABLE --
DROP TABLE person;

CREATE TABLE person (
    person_id       INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    lastname        VARCHAR2(40 CHAR),
    firstname       VARCHAR2(25 CHAR),
    middlename      VARCHAR2(3 CHAR),
    fullname        VARCHAR2(55 CHAR),
    dob             DATE,
    highest_degree  NUMBER,
    title           VARCHAR2(15 CHAR),
    gender          VARCHAR2(10 CHAR)
);

ALTER TABLE person ADD CONSTRAINT person_pk PRIMARY KEY ( person_id );

INSERT INTO person (
    lastname,
    firstname,
    middlename,
    dob,
    highest_degree,
    title,
    fullname,
    gender
)
    SELECT
        lastname,
        firstname,
        middlename,
        dob,
        highest_degree,
        title,
        title
        || ' '
        || firstname
        ||
        CASE
            WHEN middlename IS NOT NULL THEN
                    ' '
                    || middlename
                    || '. '
            ELSE
                ' '
        END
        || lastname fullname,
        gender
    FROM
        (
            SELECT
                p.lastname,
                p.firstname,
                TRIM(substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ                ', abs(mod(dbms_random.random, length('ABCDEFGHIJKLMNOPQRSTUVWXYZ                '))),
                            1))    middlename,
                dob,
                p.highest_degree,
                p.gender,
                CASE
                    WHEN p.highest_degree < 3 THEN
                            CASE p.gender
                                WHEN 'Female' THEN
                                    'Ms.'
                                ELSE
                                    'Mr.'
                            END
                    ELSE
                        'Dr.'
                END    title
            FROM
                x_person p
        )
    ORDER BY
        highest_degree DESC;
        
commit;


==> 03_university.sql <==
ALTER SESSION SET container = xepdb1;

SELECT
    MAX(length(name)),
    MAX(length(year_founded)),
    MAX(length(public_university))
FROM
    x_university;

-- create university table --
DROP TABLE university;

CREATE TABLE university (
    university_id      INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    university_name    VARCHAR2(80 CHAR),
    year_founded       INTEGER,
    public_university  CHAR(1),
    avg_tuition        INTEGER,
    address_id         INTEGER
);

ALTER TABLE university ADD CONSTRAINT university_pk PRIMARY KEY ( university_id );

ALTER TABLE university
    ADD CONSTRAINT university_address_fk FOREIGN KEY ( address_address_id )
        REFERENCES address ( address_id );
        
-- load university table --
INSERT INTO university (
    university_name,
    year_founded,
    public_university,
    avg_tuition
)
    SELECT
        name university_name,
        year_founded,
        CASE public_university
            WHEN 'TRUE' THEN
                'X'
            ELSE
                NULL
        END,
        round(avg_tuition)
    FROM
        x_university;

SELECT
    *
FROM
    university;

-- match up universities with addresses --
DROP VIEW x_states;

CREATE VIEW x_states AS
    SELECT
        TRIM(state)            state,
        TRIM(abbreviation)     abbreviation
    FROM
        (
            SELECT
                'Alabama  '  state,
                'AL '        abbreviation
            FROM
                dual
            UNION
            SELECT
                'Alaska  ' state,
                'AK '
            FROM
                dual
            UNION
            SELECT
                'Arizona  ' state,
                'AZ '
            FROM
                dual
            UNION
            SELECT
                'Arkansas  ' state,
                'AR '
            FROM
                dual
            UNION
            SELECT
                'California  ' state,
                'CA '
            FROM
                dual
            UNION
            SELECT
                'Colorado  ' state,
                'CO '
            FROM
                dual
            UNION
            SELECT
                'Connecticut  ' state,
                'CT '
            FROM
                dual
            UNION
            SELECT
                'Delaware  ' state,
                'DE '
            FROM
                dual
            UNION
            SELECT
                'District of Columbia  ' state,
                'DC '
            FROM
                dual
            UNION
            SELECT
                'Florida  ' state,
                'FL '
            FROM
                dual
            UNION
            SELECT
                'Georgia  ' state,
                'GA '
            FROM
                dual
            UNION
            SELECT
                'Hawaii  ' state,
                'HI '
            FROM
                dual
            UNION
            SELECT
                'Idaho  ' state,
                'ID '
            FROM
                dual
            UNION
            SELECT
                'Illinois  ' state,
                'IL '
            FROM
                dual
            UNION
            SELECT
                'Indiana  ' state,
                'IN '
            FROM
                dual
            UNION
            SELECT
                'Iowa  ' state,
                'IA '
            FROM
                dual
            UNION
            SELECT
                'Kansas  ' state,
                'KS '
            FROM
                dual
            UNION
            SELECT
                'Kentucky  ' state,
                'KY '
            FROM
                dual
            UNION
            SELECT
                'Louisiana  ' state,
                'LA '
            FROM
                dual
            UNION
            SELECT
                'Maine  ' state,
                'ME '
            FROM
                dual
            UNION
            SELECT
                'Maryland  ' state,
                'MD '
            FROM
                dual
            UNION
            SELECT
                'Massachusetts  ' state,
                'MA '
            FROM
                dual
            UNION
            SELECT
                'Michigan  ' state,
                'MI '
            FROM
                dual
            UNION
            SELECT
                'Minnesota  ' state,
                'MN '
            FROM
                dual
            UNION
            SELECT
                'Mississippi  ' state,
                'MS '
            FROM
                dual
            UNION
            SELECT
                'Missouri  ' state,
                'MO '
            FROM
                dual
            UNION
            SELECT
                'Montana  ' state,
                'MT '
            FROM
                dual
            UNION
            SELECT
                'Nebraska  ' state,
                'NE '
            FROM
                dual
            UNION
            SELECT
                'Nevada  ' state,
                'NV '
            FROM
                dual
            UNION
            SELECT
                'New Hampshire  ' state,
                'NH '
            FROM
                dual
            UNION
            SELECT
                'New Jersey  ' state,
                'NJ '
            FROM
                dual
            UNION
            SELECT
                'New Mexico  ' state,
                'NM '
            FROM
                dual
            UNION
            SELECT
                'New York  ' state,
                'NY '
            FROM
                dual
            UNION
            SELECT
                'North Carolina  ' state,
                'NC '
            FROM
                dual
            UNION
            SELECT
                'North Dakota  ' state,
                'ND '
            FROM
                dual
            UNION
            SELECT
                'Ohio  ' state,
                'OH '
            FROM
                dual
            UNION
            SELECT
                'Oklahoma  ' state,
                'OK '
            FROM
                dual
            UNION
            SELECT
                'Oregon  ' state,
                'OR '
            FROM
                dual
            UNION
            SELECT
                'Pennsylvania  ' state,
                'PA '
            FROM
                dual
            UNION
            SELECT
                'Puerto Rico  ' state,
                'PR '
            FROM
                dual
            UNION
            SELECT
                'Rhode Island  ' state,
                'RI '
            FROM
                dual
            UNION
            SELECT
                'South Carolina  ' state,
                'SC '
            FROM
                dual
            UNION
            SELECT
                'South Dakota  ' state,
                'SD '
            FROM
                dual
            UNION
            SELECT
                'Tennessee  ' state,
                'TN '
            FROM
                dual
            UNION
            SELECT
                'Texas  ' state,
                'TX '
            FROM
                dual
            UNION
            SELECT
                'Utah  ' state,
                'UT '
            FROM
                dual
            UNION
            SELECT
                'Vermont  ' state,
                'VT '
            FROM
                dual
            UNION
            SELECT
                'Virginia  ' state,
                'VA '
            FROM
                dual
            UNION
            SELECT
                'Virgin Islands  ' state,
                'VI '
            FROM
                dual
            UNION
            SELECT
                'Washington  ' state,
                'WA '
            FROM
                dual
            UNION
            SELECT
                'West Virginia  ' state,
                'WV '
            FROM
                dual
            UNION
            SELECT
                'Wisconsin  ' state,
                'WI '
            FROM
                dual
            UNION
            SELECT
                'Wyoming  ' state,
                'WY '
            FROM
                dual
        );

-- remove redundant universities --
DELETE FROM university xxx
WHERE
    EXISTS (
        SELECT
            uni.university_id,
            uni.university_name,
            dups.rank_position
        FROM
                 university uni
            JOIN (
                SELECT
                    b.cnt,
                    a.university_id,
                    a.university_name,
                    RANK()
                    OVER(PARTITION BY a.university_name
                         ORDER BY a.university_id
                    ) rank_position
                FROM
                         university a
                    JOIN (
                        SELECT
                            COUNT(*) cnt,
                            university_name
                        FROM
                            university
                        GROUP BY
                            university_name
                        HAVING
                            COUNT(*) > 1
                    ) b ON ( a.university_name = b.university_name )
                ORDER BY
                    a.university_name,
                    a.university_id
            ) dups ON ( uni.university_id = dups.university_id )
        WHERE
                rank_position > 1
            AND xxx.university_id = uni.university_id
    );

COMMIT;
    

-- find universities with names in a state and city  --
COMMIT;

SELECT
    COUNT(*),
    address_id
FROM
    university
WHERE
    address_id IS NOT NULL
GROUP BY
    address_id
HAVING
    COUNT(*) > 1;

MERGE INTO university uni
USING (
          SELECT
              university_id,
              address_id
          FROM
              (
                  SELECT
                      u.university_id,
                      u.university_name,
                      u.year_founded,
                      b.city,
                      s.abbreviation,
                      b.address_id,
                      b.addr1,
                      RANK()
                      OVER(PARTITION BY u.university_id
                           ORDER BY b.address_id
                      )  address_rank,
                      RANK()
                      OVER(PARTITION BY b.address_id
                           ORDER BY u.university_id
                      )  university_rank
                  FROM
                           (
                          SELECT
                              *
                          FROM
                              university
                          WHERE
                              university.address_id IS NULL
                      ) u
                      JOIN x_states  s ON ( u.university_name LIKE '%'
                                                                  || s.state
                                                                  || '%'
                                           AND university_id < 2000 )
                      JOIN ( -- all of the city/state combinations
                                                                                                                                                                                                        SELECT
                              a.address_id,
                              a.addr1    addr1,
                              state      abbreviation,
                              city
                          FROM
                              address a
                              LEFT OUTER JOIN university ON ( university.address_id = a.address_id )
                          WHERE
                              university.university_id IS NULL
                      )         b ON ( s.abbreviation = b.abbreviation
                               AND upper(u.university_name) LIKE '%'
                                                                 || b.city
                                                                 || '%' )
              )
          WHERE
                  address_rank = 1
              AND university_rank = 1
      )
uno ON ( uni.university_id = uno.university_id )
WHEN MATCHED THEN UPDATE
SET uni.address_id = uno.address_id;

-- next, do the ones with a state --
COMMIT;

SELECT
    COUNT(*),
    address_id
FROM
    university
WHERE
    address_id IS NOT NULL
GROUP BY
    address_id
HAVING
    COUNT(*) > 1;
rollback;
MERGE INTO university uni
USING (
          SELECT
              university_id university_id,
              b_address_id address_id,
              uni_address_id
          FROM
              (
                  SELECT
                      u.university_id,
                      u.university_name,
                      u.year_founded,
                      u.address_id uni_address_id,
                      b.city,
                      s.abbreviation,
                      b.address_id b_address_id,
                      b.addr1,
                      RANK()
                      OVER(PARTITION BY u.university_id
                           ORDER BY b.address_id
                      )  address_rank,
                      RANK()
                      OVER(PARTITION BY b.address_id
                           ORDER BY u.university_id
                      )  university_rank
                  FROM
                           (
                          SELECT
                              *
                          FROM
                              university
                          WHERE
                              university.address_id IS NULL
                      ) u
                      JOIN x_states  s ON ( u.university_name LIKE '%'
                                                                  || s.state
                                                                  || '%'
                                           --AND university_id < 3910 
                                           )
                      JOIN ( -- all of the city/state combinations
                                                                                                                                                                                                        SELECT
                              a.address_id,
                              a.addr1    addr1,
                              state      abbreviation,
                              city
                          FROM
                              address a
                              LEFT OUTER JOIN university ON ( university.address_id = a.address_id )
                          WHERE
                              university.university_id IS NULL
                      )         b ON ( s.abbreviation = b.abbreviation)
              )
          WHERE
                  address_rank = 1
              AND university_rank = 1

      )
uno ON ( uni.university_id = uno.university_id )
WHEN MATCHED THEN UPDATE
SET uni.address_id = uno.address_id;

-- do the rest -- 
MERGE INTO university unii
USING (
          SELECT
              uni.university_id,
              uni.university_name,
              addr.address_id
          FROM
                   (
                  SELECT
                      ROWNUM numm,
                      university_id,
                      university_name,
                      address_id
                  FROM
                      x_uni_sans_address
              ) uni
              JOIN (
                  SELECT
                      ROWNUM numm,
                      address_id,
                      addr1
                  FROM
                      x_address_unassigned
              ) addr ON ( uni.numm = addr.numm )
      )
uno ON ( unii.university_id = uno.university_id )
WHEN MATCHED THEN UPDATE
SET unii.address_id = uno.address_id;



ALTER SESSION SET container = xepdb1;

CREATE VIEW x_uni_sans_address AS
    SELECT
        *
    FROM
        university
    WHERE
        address_id IS NULL;

drop view x_address_unassigned;
CREATE VIEW x_address_unassigned AS
    SELECT
        a.*
    FROM
        address     a
        LEFT OUTER JOIN university  u ON ( a.address_id = u.address_id )
    WHERE
        u.address_id IS NULL;
        
        select * from x_address_unassigned;
        commit;

-----------------------------



==> 04_person.sql <==

==> 04_person_to_address.sql <==
DROP TABLE person_to_address;

CREATE TABLE person_to_address (
    address_eff_date  DATE,
    person_id         INTEGER,
    address_id        INTEGER NOT NULL
);

-- insert addresses for people --

insert into person_to_address(address_eff_date, person_id, address_id)
SELECT
      TO_DATE(
              TRUNC(
                   DBMS_RANDOM.VALUE(TO_CHAR(DATE '2018-01-01','J')
                                    ,TO_CHAR(DATE '2020-01-31','J')
                                    )
                    ),'J'
               ),
      person_id,
      address_id
  FROM
           (
          SELECT
              ROWNUM AS pnumm,
              person_id
          FROM
              person
      ) per
      JOIN (
          SELECT
              ROWNUM AS anumm,
              address_id
          FROM
              x_address_unassigned
      ) ON ( pnumm = anumm )
      
      
==> 05_faculty.sql <==
CREATE VIEW x_faculty_stage AS
    SELECT
        'Faculty of Anthropology'  name,
        'X'                        stem,
        NULL                       professional
    FROM
        dual
    UNION
    SELECT
        'Faculty of Architecture',
        NULL,
        'X'
    FROM
        dual
    UNION
    SELECT
        'Faculty of Arts and Humanities',
        NULL,
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Chemistry',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Civil Engineering',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Computer Science and Management',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Electrical Engineering',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Electronics',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of English',
        NULL,
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Environmental Engineering',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Fundamental Problems of Technology',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Geoengineering, Mining and Geology',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of History',
        NULL,
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Mechanical Engineering',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Mechanical and Power Engineering',
        'X',
        NULL
    FROM
        dual
    UNION
    SELECT
        'Faculty of Microsystem Electronics and Photonics',
        'X',
        NULL
    FROM
        dual;

COMMIT;

SELECT
    *
FROM
    x_faculty_state;

SELECT
    MAX(length(name)),
    MAX(length(stem)),
    MAX(length(professional))
FROM
    x_faculty_stage;

DROP TABLE faculty;

CREATE TABLE faculty (
    faculty_id     INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    name           VARCHAR2(50 CHAR),
    year_founded   VARCHAR2(4 CHAR),
    building       VARCHAR2(2 CHAR),
    stem           VARCHAR2(1 CHAR),
    professional   VARCHAR2(1 CHAR),
    university_id  INTEGER,
    address_id     INTEGER
);

COMMIT;

INSERT INTO faculty (
    name,
    stem,
    professional,
    university_id
)
    SELECT
        xf.name,
        xf.stem,
        xf.professional,
        uni.university_id
    FROM
             x_faculty_stage xf
        CROSS JOIN university uni;

COMMIT;

SELECT
    *
FROM
    faculty;

--update the date founded

MERGE INTO faculty
USING (
          SELECT
              f.faculty_id,
              u.university_id,
              u.address_id,
              trunc(dbms_random.value(10, 30)) bldg,
              CASE
                  WHEN f.stem IS NULL THEN
                      trunc(dbms_random.value(u.year_founded, u.year_founded + 5))
                  ELSE
                      trunc(dbms_random.value(u.year_founded, u.year_founded + 5))
              END year_founded
          FROM
                   faculty f
              JOIN university u ON ( f.university_id = u.university_id )
      )
f_stage ON ( faculty.faculty_id = f_stage.faculty_id )
WHEN MATCHED THEN UPDATE
SET faculty.year_founded = f_stage.year_founded,
    faculty.address_id = f_stage.address_id, faculty.building = f_stage.bldg;
    
    commit;
    
select * from faculty;


==> 06_course.sql <==
CREATE TABLE course (
    course_id           INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    course_title        VARCHAR2(50 CHAR) NOT NULL,
    credits             INTEGER,
    course_level        INTEGER NOT NULL,
    person_person_id    INTEGER,
    start_date          DATE,
    end_date            DATE,
    faculty_faculty_id  INTEGER
);

INSERT INTO course (
    course_title,
    credits,
    course_level,
    faculty_faculty_id,
    start_date,
    end_date
)
    SELECT
        course,
        credits,
        course_level,
        faculty,
        '01-jan-2020'  start_date,
        '01-mar-2020'  end_date
    FROM
        (
            SELECT
                CASE round(dbms_random.value(1, 4))
                    WHEN 1  THEN
                        'Chemistry'
                    WHEN 2  THEN
                        'Physics'
                    WHEN 3  THEN
                        'Algebra'
                    WHEN 4  THEN
                        'Calculus'
                END                                            course,
                trunc(dbms_random.value(1, 5))                 credits,
                trunc(dbms_random.value(1, 5))                 course_level,
                trunc(dbms_random.value(1000, 5000))           faculty
            FROM
                faculty
            WHERE
                ROWNUM < 1000
        );

COMMIT;

MERGE INTO course
USING (
          SELECT
              c.course_id course_id,
              p.person_id
          FROM
                   (
                  SELECT
                      ROWNUM rn,
                      course_id
                  FROM
                      course c
              ) c
              JOIN (
                  SELECT
                      ROWNUM rn,
                      person_id
                  FROM
                      person p
                  WHERE
                          ROWNUM < 1000
                      AND highest_degree = 0
              ) p ON ( p.rn = c.rn )
      )
xx ON ( xx.course_id = course.course_id )
WHEN MATCHED THEN UPDATE
SET course.person_person_id = xx.person_id;

commit;
==> 07_role.sql <==
CREATE TABLE role (
    rolename            INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    role_level          INTEGER,
    privileged          VARCHAR2(1 CHAR),
    role_type           VARCHAR2(1 CHAR) NOT NULL,
    new_role            VARCHAR2(1),
    person_person_id    INTEGER,
    faculty_faculty_id  INTEGER,
    active              VARCHAR2(1),
    eff_date            DATE
);

COMMIT;

INSERT INTO role (
    role_level,
    privileged,
    role_type,
    new_role,
    person_person_id,
    faculty_faculty_id,
    active,
    eff_date
)
    SELECT
        '1',
        NULL,
        'S',
        NULL,
        p.person_id,
        c.faculty_faculty_id,
        'X',
        '01-jan-2020'
    FROM
             person p
        JOIN course c ON ( p.person_id = c.person_person_id );

COMMIT;
==> 08_grades.sql <==
CREATE TABLE grades (
    grades_id         INTEGER
        GENERATED BY DEFAULT AS IDENTITY START WITH 1000,
    min               FLOAT,
    max               FLOAT,
    received_mark     FLOAT,
    representation    VARCHAR2(5 CHAR),
    passing_grade     FLOAT,
    person_person_id  INTEGER
);

COMMIT;

ALTER TABLE grades ADD CONSTRAINT grades_pk PRIMARY KEY ( grades_id ); 

insert into grades(min, max, received_mark, representation, passing_grade, person_person_id)
SELECT
minn,
maxx,
received_mark,
CASE received_mark
WHEN 2  THEN
'F'
WHEN 3  THEN
'C'
WHEN 4  THEN
'B'
WHEN 5  THEN
'A'
ELSE
'X'
END representation,
3,
z.person_id
FROM
(
SELECT
2                                        minn,
5                                        maxx,
trunc(dbms_random.value(2, 6))           received_mark,
3                                        passing_grade,
p.person_id
FROM
person p join course c on (p.person_id = c.person_person_id)
) z;

commit;
